---
title: An R Markdown document converted from "RanDonnees_2022_atelier_manipulation_R.ipynb"
output: html_document
---

# Atelier 6- Traitement des donn√©es avec **R**

Bienvenue √† cet atelier sur la manipulation et le nettoyage de donn√©es avec R.

Cet atelier a √©t√© d√©velopp√© √† partir des ateliers sur la manipulation de donn√©es
de [Software
Carpentry](https://swcarpentry.github.io/r-novice-gapminder/13-dplyr/index.html)
(liens suppl√©mentaires √† la fin du document). Il fait suite √† l'atelier
d'introduction pr√©sent√© par **Francis Banville**. D'autres ressources sont
√©galement disponibles au [repo GitHub
suivant](https://github.com/gabrieldansereau/RanDonnees2022-atelier-manipulation-R).

### Auteur

Gabriel Dansereau (il/lui), √©tudiant au doctorat en sciences biologiques √†
l'Universit√© de Montr√©al

üìß gabriel.dansereau@umontreal.ca 

19 janvier 2022

# Introduction

## Objectif

L'objectif de cet atelier est de vous familiariser avec la manipulation et au
nettoyage de donn√©es avec _R_ pour que vous puissez r√©aliser ces op√©rations par
vous-m√™me sur vos propres jeux de donn√©es. Nous reverrons des fonctions qui vous
ont d√©j√† √©t√© pr√©sent√©es, mais de mani√®re un peu plus exhaustive afin de vous
montrer diff√©rentes possibilit√©s de manipulation.

## Contenu

1. Op√©rations de base pour manipuler les donn√©es
2. Nettoyage d'un jeu de donn√©es
3. R√©organisation d'un jeu de donn√©es

## Ressources utiles avant de commencer

- [Cheat sheet dplyr](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)
- [Cheat sheet tidyr](https://raw.githubusercontent.com/rstudio/cheatsheets/main/tidyr.pdf)

## Pr√©paration du jeu de donn√©es

```{r}
# Charger le package n√©cessaire pour r√©aliser les manipulations
if (!require(tidyverse)) {
  installed.packages("tidyverse")
}
library(tidyverse)
```

```{r}
# Charger le jeu de donn√©es gapminder
gapminder_url <- "https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_data.csv"
dir.create("data")
download.file(gapminder_url, destfile = "data/gapminder_data.csv")
gapminder <- read_csv("data/gapminder_data.csv")
```

```{r}
# Visualiser le jeu de donn√©es complet
gapminder
```

```{r}
# Pour visualiser les premi√®res lignes seulement (6 lignes par d√©faut)
head(gapminder)
```

```{r}
# Google Colab pr√©sente les tibbles diff√©rement des consoles R normales
# Seul l'aspect visuel est diff√©rent. Le contenu est identique pour R
# Pour les voir de la m√™me fa√ßon, on peut utiliser `print()`
print(gapminder)

# Pour voir toutes les lignes
# print(gapminder, n = Inf)
```

```{r}
# Une autre fa√ßon de visualiser le contenu des colonnes
glimpse(gapminder)
```

```{r}
# Regardons quelques d√©tails sur le jeu de donn√©es
summary(gapminder)
```

# 1.0 Les op√©rations de base pour manipuler les donn√©es

Nous verrons dans cet atelier les fonctions `tidyverse`, un ensemble de packages
qui rendent la manipulation de donn√©es et le nettoyage tr√®s efficace, en
particulier `dplyr` et `tidyr`. Cela dit, il est souvent possible de r√©aliser
les m√™mes op√©rations avec les fonctions de base de R (_base-R_). J'ai donc mis
quelques exemples afin de comparer.

Le package `dplyr` est le plus important pour la manipulation de donn√©es. Il
comprend 5 op√©rations de base, que nous survolerons dans cette section.

1. `select`: s√©lection de colonnes
2. `filter`: s√©lections de rang√©es
3. `group_by`: regroupement par cat√©gories
4. `summarize`: r√©aliser des op√©rations sur les groupes
5. `mutate`: ajout de colonnes

## 1.1 S√©lection de colonnes avec `select`

_Note: J'utilise la fonction `head()` simplement pour √©viter d'afficher trop de
rang√©es √† la fois. La fonction n'est pas n√©cessaire pour la manipulation de
donn√©es en soi._

```{r}
# S√©lectionner certaines colonnes seulement
gapminder_selection <- select(gapminder, year, country, gdpPercap)
head(gapminder_selection)
```

```{r}
# La m√™me op√©ration, mais en utilisant `%>%` (pipe, ou tuyau)
# Le pipe se combine bien avec toutes les fonctions o√π le jeu de donn√©es est le 
# premier argument, comme `head()`
gapminder %>%
  select(year, country, gdpPercap) %>%
  head()
```

```{r}
# Remarquez que l'ordre de s√©lection d√©termine l'ordre de pr√©sentation des colonnes
gapminder %>%
  select(country, year, gdpPercap) %>%
  head()
```

```{r}
# Retirer une colonne donn√©e
gapminder %>%
  select(-lifeExp, -pop) %>%
  head()
```

## 1.2 S√©lection de rang√©es avec `filter`

```{r}
# S√©lectionner les rang√©es appartenant √† une seule cat√©gorie
gapminder %>%
  filter(continent == "Europe") %>%
  select(year, country, gdpPercap) %>%
  head()
```

Remarquez que l'ordre des op√©rations n'est pas interchangeable dans ce cas-ci, 
puisqu'on retire la colonne `continent`.

```{r}
# Cette op√©ration est encore r√©alisable avec base-R (deux fa√ßons)
head(gapminder[gapminder$continent == "Europe", c("year", "country", "gdpPercap")])
head(subset(gapminder, continent == "Europe", select = c("year", "country", "gdpPercap")))
```

```{r}
# S√©lectionner les rang√©es appartenant √† deux cat√©gories
gapminder %>% 
  filter(continent %in% c("Europe", "Africa")) %>%
  head()
```

```{r}
# Filter les rang√©es selon deux crit√®res diff√©rents
gapminder %>%
  filter(continent == "Europe", year >= 2007) %>%
  head()
```

```{r}
# Filter les rang√©es √† partir d'une √©tendue de valeurs
gapminder %>%
  filter(continent == "Europe", between(year, 2000, 2010)) %>%
  head()
```

## D√©fi 1

√âcrivez une commande qui produit un data frame (un `tibble`) avec les valeurs 
pour l'**Afrique seulement** et qui ne montre que le contenu des colonnes 
`lifeExp`, `country` et `year`. Combien de rang√©es le data frame contient-il?

```{r}

```

## 1.3 Regrouper des √©l√©ments avec `group_by`

```{r}
# Regrouper par continent
groupes_continent <- group_by(gapminder, continent)
head(groupes_continent)
```

```{r}
# Propri√©t√©s du jeu de donn√©es group√©
glimpse(groupes_continent)
```

```{r}
# Esp√©rance de vie la plus √©lev√©e pour chaque continent
gapminder %>%
  group_by(continent) %>%
  filter(lifeExp == max(lifeExp))
```

## 1.4 R√©aliser des op√©rations sur les groupes avec `summarize`

```{r}
# Calculer le PIB moyen par continent
gapminder %>%
  group_by(continent) %>%
  summarize(mean_gdpPercap = mean(gdpPercap))
```

C'est ici que le `tidyverse` se d√©marque particuli√®rement. Avec base-R, il
faudrait plut√¥t r√©p√©ter l'op√©ration s√©par√©ment pour chaque groupe, puis
assembler les lignes une √† une, ou encore utiliser une boucle `for`. Dans tous
les cas, le code r√©sultant serait s√ªrement plus long et moins intuitif.

```{r}
# Grouper avec plusieurs variables √† la fois
gapminder %>%
  group_by(continent, year) %>%
  summarize(mean_gdpPercap = mean(gdpPercap))
```

```{r}
# On peut √©galement d√©finir plusieurs nouvelles variables simultan√©ment.
# Par exemple, on calculer la moyenne et l'√©cart-type de deux variables.
gapminder %>%
  group_by(continent, year) %>%
  summarize(mean_gdpPercap = mean(gdpPercap),
            sd_gdpPercap = sd(gdpPercap),
            mean_pop = mean(pop),
            sd_pop = sd(pop))
```

Consultez la [Cheat Sheet sur la transformation de
donn√©es](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)
pour avoir une id√©e des fonctions qui peuvent √™tre utilis√©es avec `summarize()`.

## D√©fi 2

Calculez l'esp√©rance de vie moyenne par pays. Essayez ensuite de trouver lequel
a l'esp√©rance de vie la plus **longue**.

```{r}

```

*Suggestion: La fonction `arrange` peut vous aider √† classer les rang√©es en
ordre croissant ou d√©croissant.*

## 1.5 Ajout de nouvelles colonnes avec `mutate()`

```{r}
# Ajouter la population en millions et calculer le PIB total en milliards
gapminder %>%
  mutate(pop_million = pop / 10^6,
         gdp_billion = gdpPercap * pop / 10^9) %>%
  head()
```

```{r}
# L'ajout d'une nouvelle colonne fonctionne √©videmment avec base-R
gapminder_copie <- gapminder
gapminder_copie$gdp_billion <- gapminder_copie$gdpPercap * gapminder_copie$pop / 10^9
head(gapminder_copie)
```

```{r}
# `mutate` peut √©galement modifier une colonne existante
gapminder %>%
  mutate(pop = pop / 10^6) %>%
  head()
```

```{r}
# Ajouter une variable en fonction d'une condition logique
gapminder %>%
    mutate(century = ifelse(year >= 2000, "21st", "20th")) %>%
    select(country, year, century) %>%
    tail()
```

```{r}
# Plus complexe: modifier une valeur seulement si une condition est remplie
# Pour une esp√©rance de vie de plus de 40 ans, accro√Ætre le PIB par 1.5
gapminder %>%
    mutate(gdp_futureExpectation = ifelse(lifeExp > 40, gdpPercap * 1.5, gdpPercap)) %>%
    group_by(continent) %>%
    summarize(mean_gdpPercap = mean(gdpPercap),
              mean_gdpPercap_expected = mean(gdp_futureExpectation))
```

## 1.6 Autres fonctions utiles

### `rename`: Renommer les colonnes

```{r}
# Renommer des colonnes
gapminder_rename <- gapminder %>%
  rename(life_exp = lifeExp, 
         gdp_per_cap = gdpPercap)

# Les colonnes renomm√©es:
head(gapminder_rename)
```

```{r}
# Renommer les colonnes en fran√ßais
gapminder_fr <- gapminder %>%
  rename(pays = country,
         annee = year, 
         esp_vie = lifeExp, 
         pib_par_hab = gdpPercap)

# Les colonnes en fran√ßais:
head(gapminder_fr)

# √Ä noter: Les noms de colonnes n'ont pas √©t√© chang√©es dans le jeu de donn√©es 
# original. Nous continuerons donc √† utiliser les noms en anglais
```

### `count()`: compter le nombre d'observations

```{r}
# D√©terminer le nombre d'observations par continent
gapminder %>%
    filter(year == 2002) %>%
    count(continent, sort = TRUE)
```

### `relocate()`: d√©placer des colonnes

```{r}
# Regarder l'ordre initial des colonnes
head(gapminder)
```

```{r}
# D√©placer des colonnes
gapminder %>% 
  relocate(continent, .before = year) %>%
  relocate(pop, .after = last_col()) %>%
  head()
```

```{r}
# √Ä l'int√©rieur de mutate
gapminder %>%
  mutate(pop_million = pop / 10^6, .after = pop) %>%
  tail()
```

# 2.0 Nettoyage d'un jeu de donn√©es

Le jeu de donn√©es `gapminder` que nous avons utilis√© jusqu'√† pr√©sent avait d√©j√†
√©t√© nettoy√©. Tant mieux si c'est √©galement le cas pour vos projets! Dans la
plupart des cas, il est cependant n√©cessaire de faire un peu de nettoyage et de
v√©rifier si les donn√©es ont du sens.

Dans cette section, nous allons travailler avec une version de `gapminder` que
modifi√©e pour reproduire certaines erreurs communes qui peuvent s'introduire
dans vos donn√©es. Nous allons voir comment les rep√©rer et les corriger √† l'aide
de _R_. Ce ne sont pas les seules erreurs possibles √©videmment et, avec un peu
de chance, vous n'aurez pas √† les corriger sur vos propres donn√©es. Nous aurons
√©galement l'occasion de pratiquer les op√©rations de traitement montr√©es
pr√©c√©demment.

Commen√ßons par charger le jeu de donn√©es:

```{r}
# Charger le jeu de donn√©es √† nettoyer
messy_url <- "https://raw.githubusercontent.com/gabrieldansereau/RanDonnees2022-atelier-manipulation-R/main/gapminder_messy.csv"
gapminder_messy <- read_csv(messy_url)
head(gapminder_messy)
```

```{r}
# Charger correctement
gapminder_messy <- read_csv2(messy_url)
head(gapminder_messy, 15)
```

Combien d'erreurs pouvez-vous identifier dans l'aper√ßu du jeu de donn√©es?

## 2.1 R√©parer la structure du jeu de donn√©es

Nous allons maintenant corriger les erreurs pour r√©parer et nettoyer le jeu de
donn√©es. Les op√©rations sont dans un ordre qui raisonnable pour ce jeu de
donn√©es, mais il est possible qu'elles doivent √™tre r√©alis√©es dans  un ordre
diff√©rent avec un autre jeu de donn√©es.

### 1. Corriger l'ent√™te

```{r}
# Sauter la premi√®re ligne de commentaires pour corriger l'ent√™te
gapminder_messy <- read_csv2(messy_url, skip = 1)
head(gapminder_messy)
```

### 2. Retirer la ligne avec les unit√©s de mesure

```{r}
# Retirer la ligne avec les unit√©s
gapminder_messy <- gapminder_messy %>%
  slice(-1)

# Slice peut √©galement s√©lectionner des lignes
slice(gapminder_messy, 1:6)
```

### 3. Renommer la colonne contenant des espaces

```{r}
# Regardons le jeu de donn√©es comme il est montr√© en R
print(gapminder_messy, n = 6)
```

```{r}
# Comment travailler avec la colonne contenant des espaces?
select(gapminder_messy, `gdp Per cap`) %>% head(1)
select(gapminder_messy, "gdp Per cap") %>% head(1)
gapminder_messy[1, "gdp Per cap"]
```

```{r}
# Renommer une colonne contenant des espaces
gapminder_messy %>%
  rename(gdpPercap = `gdp Per cap`) %>%
  head()
```

```{r}
# Renommer plusieurs colonnes √† la fois (m√™me si ce n'est pas n√©cessaire dans ce cas-ci)
gapminder_messy <- gapminder_messy %>%
  rename_with(~ gsub(" ", "", .x))
head(gapminder_messy)
```

### 4. Corriger le type des colonnes

```{r}
# Quel est le type des colonnes?
head(gapminder_messy, 1)
typeof(gapminder_messy$gdpPercap)
typeof(gapminder_messy$lifeExp)
```

```{r}
# La colonne gdpPercap est de type `character`, mais elle devrait plut√¥t
# √™tre de type `double` comme la colonne lifeExp

# V√©rifions si cela pose probl√®me en essayant de calculer la moyenne
gapminder_messy %>% 
  summarize(gdpPercap_mean = mean(gdpPercap),
            pop_mean = mean(pop))
```

```{r}
# En raison du type, il n'est possible de calculer la moyenne de `gdpPercap` 
# comme pour `pop`. Il faut donc corriger celui-ci.

# Rempla√ßons d'abord les virgules par des points.
gapminder_messy <- gapminder_messy %>%
  mutate(gdpPercap = gsub(",", ".", gdpPercap))

# Notez que le type est toujours `character`.
head(gapminder_messy)
```

```{r}
# Nous pouvons maintenant convertir en `double`
gapminder_messy <- gapminder_messy %>%
  mutate(gdpPercap = as.double(gdpPercap))

# Le type est maintenant bel et bien `double`
head(gapminder_messy)

# Il est donc possible de calculer la moyenne
gapminder_messy %>% 
  summarize(gdpPercap_mean = mean(gdpPercap),
            pop_mean = mean(pop))
```

```{r}
head(gapminder_messy)
```

### D√©fi 3

R√©parez le jeu de donn√©es suivant et calculez l'esp√©rance de vie **m√©diane** par
ann√©e.

```{r}
# Charger le nouveau jeu de donn√©es
url_defi <- "https://raw.githubusercontent.com/gabrieldansereau/RanDonnees2022-atelier-manipulation-R/main/gapminder_messy_challenges.csv"
gapminder_defi <- read_csv(url_defi)
head(gapminder_defi)
```

```{r}
# Solution
```

## 2.2 Nettoyer les valeurs au sein du jeu de donn√©es

### 5. Valeurs manquantes ou NA (Not Available)

```{r}
# Les NA peuvent-ils poser probl√®me?
gapminder_messy %>%
  group_by(year) %>%
  summarize(le_mean = mean(lifeExp),
            le_max = max(lifeExp)) %>%
  head()
```

```{r}
# Comment peut-on ignorer les NA?
# Option 1: argument `na.rm`
gapminder_messy %>%
  group_by(year) %>%
  summarize(le_mean = mean(lifeExp, na.rm = TRUE),
            le_max = max(lifeExp, na.rm = TRUE))

# Option 2: fonction `drop_na()`
gapminder_messy %>%
  group_by(year) %>%
  drop_na(lifeExp) %>%
  summarize(le_mean = mean(lifeExp),
            le_max = max(lifeExp))
```

Notez bien qu'il est g√©n√©ralement pr√©f√©rable de conserver les valeurs manquantes
et de les ignorer lors d'une op√©ration donn√©e en toute connaissance de cause. En
retirant les observations comportant des `NA` dans une colonne du jeu de
donn√©es, nous pourrions perdre des informations importantes dans d'autres
colonnes. Cela est toutefois variable d√©pendamment de la situation.

```{r}
# Comment pouvons-nous d√©tecter les NA?
# 3 fa√ßons
anyNA(gapminder_messy)
anyNA(gapminder_messy$lifeExp)
summary(gapminder_messy)
```

```{r}
# Voir seulement les rang√©es avec des NA pour une colonne
gapminder_messy %>%
  filter(is.na(lifeExp))
```

```{r}
# Voir les rang√©es avec des NA peu importe la colonne
gapminder_messy %>%
  filter(if_any(everything(), ~ is.na(.x)))
```

### 6. Identifier les doublons

```{r}
# Y'a-t-il des doublons dans notre jeu de donn√©es?
head(gapminder_messy)
```

```{r}
# Comment pouvons-nous trouver les doublons?
# √Ä noter que cette fonction ne retourne que la 2e rang√©e du doublon
gapminder_messy[duplicated(gapminder_messy), ]
```

```{r}
# Retirer les doublons
gapminder_messy <- gapminder_messy %>%
  distinct()

# La 2e rang√©e du doublon a √©t√© retir√©e
head(gapminder_messy)
```

```{r}
# Il est √©galement possible de trouver les combinaisons distinctes de 2 variables
# Ce qui nous permet de voir certaines erreurs facilement...
gapminder_messy %>%
  distinct(continent, country) %>%
  head()
```

### 7. Trouver et corriger les erreurs de frappe

```{r}
# Il est parfois assez facile de trouver des erreurs de frappe avec `distinct`, 
# en particulier pour les variables qui comportent peu de cat√©gories
gapminder_messy %>%
  distinct(continent)
```

```{r}
# Par contre, d'autres variables peuvent contenir trop de cat√©gories pour √™tre
# v√©rifi√©es rapidement
gapminder_messy %>%
  distinct(country) %>%
  nrow()
```

```{r}
# Une techique efficace pour trouver les doublons (dans ce cas-ci) est de compter
# le nombre de fois o√π chaque valeur a √©t√© observ√©e

# Dans le cas du jeu de donn√©es `gapminder`, le nombre d'observations par pays
# devrait √™tre identique. De plus, un pays ne devrait se trouver que sur un seul 
# continent

# `count` et `arrange` sont donc tr√®s utiles dans ce cas
gapminder_messy %>%
  count(country, continent) %>%
  arrange(n) %>% 
  head(10)

# Dans notre cas, il y a 4 valeurs qui ne reviennent qu'une fois et qui sont 
# probablement des fautes de frappe
```

```{r}
# Diff√©rentes fonctions peuvent √™tre utilis√©es pour remplacer les valeurs et 
# corriger les erreurs selon la situation
gapminder_messy <- gapminder_messy %>%
  mutate(continent = str_replace(continent, "Asiaa", "Asia"),
         country = str_replace_all(country, c("Afganistan" = "Afghanistan", 
                                              "zimbabwe" = "Zimbabwe")),
         continent = replace(continent, country == "Afghanistan" & continent == "Americas", "Asia"))

# Les erreurs ont maintenant √©t√© corrig√©es
head(gapminder_messy)

# V√©rifions les combinaisons √† nouveau
gapminder_messy %>%
  count(country, continent) %>%
  arrange(n) %>% 
  head()
```

### 8. Trouver et identifier des valeurs aberrantes

Pour trouver des valeurs aberrantes, il faut g√©n√©ralement plonger dans nos
donn√©es et les explorer de plusieurs fa√ßons. Il est n√©cessaire de r√©fl√©chir aux
valeurs qui semblent raisonnables pour nos variables et de penser √† la mani√®re
dont certaines erreurs ont pu √™tre commises.

```{r}
# Il est parfois facile d'identifier des valeurs aberrantes en regardant les 
# valeurs limites avec `summary`
summary(gapminder_messy)
```

```{r}
# Une autre technique est d'dentifier les valeurs aberrantes visuellement
gapminder_messy %>%
  ggplot(aes(x = continent, y = lifeExp)) +
  geom_boxplot()
```

```{r}
# Identifer les rang√©es
gapminder_messy %>%
  filter(lifeExp < 20 | lifeExp > 90)
```

```{r}
# Extraire les valeurs exactes
valeurs_aberrantes <- gapminder_messy %>%
  filter(lifeExp < 20 | lifeExp > 90) %>%
  pull(lifeExp)
valeurs_aberrantes

# Corriger les valeurs
gapminder_messy <- gapminder_messy %>%
  mutate(lifeExp = replace(lifeExp, lifeExp == 0, NA),
         lifeExp = replace(lifeExp, lifeExp == valeurs_aberrantes[1], valeurs_aberrantes[1]/10))

# Les erreurs ont √©t√© corrig√©es
head(gapminder_messy, 10)
```

### D√©fi 4

Reprenez votre jeu de donn√©es `gapminder_defi` du D√©fi 3. En quelle ann√©e
l'**esp√©rance de vie** a-t-elle √©t√© la plus √©lev√©e au **Canada**? Quel √©tait le
**nombre d'habitant** cette m√™me ann√©e?

```{r}
# Voici les commandes pour le reproduire au besoin
url_defi <- "https://raw.githubusercontent.com/gabrieldansereau/RanDonnees2022-atelier-manipulation-R/main/gapminder_messy_challenges.csv"
gapminder_defi_clean <- read_csv(url_defi) %>%
  slice(-1) %>%
  rename(year = X2,
         lifeExp = `life _Exp`) %>%
  mutate(lifeExp = as.numeric(lifeExp))
```

```{r}
# Solution
```

# 3.0 R√©organisation du jeu de donn√©es

Les jeux de donn√©es sont souvent organis√©s dans un format pratique pour la
saisie des donn√©es. Or, il arrive que ce format ne convienne pas l'analyse et
complique certaines t√¢ches. Il est donc parfois n√©cessaire d'effectuer des
op√©rations en _R_ pour r√©organiser la structure des donn√©es, sans toutefois en
perdre ou risquer de faire des erreurs √† la main.

### 3.1 Pivoter du format large au format long avec `pivot_longer()`

Deux types d'organisation des jeux de donn√©es sont importants pour l'analyse: le
format `long` et le format `large`. Le format `long` est plus pratique pour
l'analyse √† l'aide d'un langage de programmation comme R, alors que le format
`large` est souvent plus instinctif pour la saisie de donn√©es. La figure
suivante produite par Software Carpentry illustre cette diff√©rence:

<p align="center">
  <img align = "center" src="https://swcarpentry.github.io/r-novice-gapminder/fig/14-tidyr-fig1.png" heigth="50%"
       title = "Format large vs long">
</p>

Le jeu de donn√©es `gapminder` est dans un format interm√©diaire, mais ressemble
plus au format long.

Les prochaines √©tapes montreront comme passer d'un format √† l'autre. Cette √©tape
peut √©galement s'av√©rer pratique lors de certaines analyses ou manipulations de
donn√©es.

Nous utiliserons pour commencer une nouvelle version large de `gapminder` (d√©j√†
nettoy√©e comme dans la premi√®re partie). Le but sera de partir de la version
large et d'arriver √† une version identique au jeu de donn√©es initial.

```{r}
# Rappel du jeu de donn√©es long
head(gapminder)
```

```{r}
# Charger le jeu de donn√©es au format large
gapminder_wide_url <- "https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder_wide.csv"
gap_wide <- read_csv(gapminder_wide_url)
head(gap_wide)
glimpse(gap_wide)
```

```{r}
# Commen√ßons par un seul type de colonne au format long
gap_wide_pop <- gap_wide %>%
  select(-starts_with("gdp"), -starts_with("life"))
glimpse(gap_wide_pop)
```

```{r}
# Pivoter toutes les colonnes pop
gap_wide_pop %>%
  pivot_longer(cols = c(starts_with("pop")),
               names_to = "type_year",
               values_to = "pop") %>%
  head()
```

```{r}
# Pivoter, puis s√©parer les colonnes
gap_wide_pop %>%
  pivot_longer(cols = c(starts_with("pop")),
               names_to = "type_year",
               values_to = "pop") %>%
  separate(type_year, into = c("type", "year"), sep = "_") %>%
  head()
```

```{r}
# R√©p√©ter avec le jeux de donn√©es large complet
gap_long <- gap_wide %>%
  pivot_longer(cols = c(starts_with("pop"), starts_with("life"), starts_with("gdp")),
               names_to = "type_year",
               values_to = "value") %>%
  separate(type_year, into = c("type", "year"))
tail(gap_long)
```

```{r}
# Convertir les ann√©es au format num√©rique et mettre en ordre comme le jeu de donn√©es initial
gap_long <- gap_long %>%
  mutate(year = as.integer(year)) %>%
  arrange(country, year)
head(gap_long)
```

```{r}
# Comparer avec le jeu de donn√©es initial
head(gapminder)
```

### 3.2 Pivoter vers un format plus large avec `pivot_wider()`

```{r}
# Pivoter au format large
gap_normal <- gap_long %>%
  pivot_wider(names_from = type,
              values_from = value)
head(gap_normal)
```

```{r}
# Comparaison avec le jeu de donn√©es initial
dim(gap_normal)
dim(gapminder)
```

```{r}
# Mettre les colonnes dans le m√™me ordre
gap_normal <- gap_normal %>%
  select(names(gapminder)) %>%
  arrange(country, year)
head(gap_normal)
```

```{r}
# V√©rifier si l'ordre correspond
names(gap_normal)
names(gapminder)
```

```{r}
# Est-ce que les jeux de donn√©es sont identiques?
all(gap_normal == gapminder)
```

# 4.0 Ressources suppl√©mentaires

Cet atelier a √©t√© d√©velopp√© √† partir des ateliers
[`dplyr`](https://swcarpentry.github.io/r-novice-gapminder/13-dplyr/index.html)
et
[`tidyr`](https://swcarpentry.github.io/r-novice-gapminder/14-tidyr/index.html)
de Software Carpentry, qui sont sous licence [CC-BY
4.0](https://creativecommons.org/licenses/by/4.0/). Le contenu a √©t√© adapt√© pour
la pr√©sentation lors du d√©fi Ran.Donn√©es 2022.

Citation originale: Naupaka Zimmerman, Greg Wilson, Raniere Silva, Scott
Ritchie, Fran√ßois Michonneau, Jeffrey Oliver, ‚Ä¶ Yuka Takemon. (2019, July).
swcarpentry/r-novice-gapminder: Software Carpentry: R for Reproducible
Scientific Analysis, June 2019 (Version v2019.06.1). Zenodo.
http://doi.org/10.5281/zenodo.3265164

## Liens pertinents

- [Cheat sheet dplyr](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)
- [Cheat sheet tidyr](https://raw.githubusercontent.com/rstudio/cheatsheets/main/tidyr.pdf)
- [Cheat sheet en fran√ßais (pas √† jour)](https://raw.githubusercontent.com/rstudio/cheatsheets/main/translations/french/data-wrangling_fr.pdf)
- [Toutes les cheat sheets de RStudio](https://www.rstudio.com/resources/cheatsheets/)
- [R for Data Science](https://r4ds.had.co.nz/)
- [Atelier du Centre sur la science de la biodiversit√© du Qu√©bec](https://r.qcbs.ca/workshop02/book-fr/manipuler-ses-donn%C3%A9es-avec-tidyr-dyplr-maggritr.html) (en fran√ßais)
- [Introduction au tidyverse par Julien Barnier](https://juba.github.io/tidyverse/index.html)  (en fran√ßais)

